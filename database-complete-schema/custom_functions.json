[
  {
    "function_name": "archive_old_bookings",
    "function_definition": "CREATE OR REPLACE FUNCTION public.archive_old_bookings()\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n  -- Insert completed bookings older than 30 days into archived_bookings\r\n  INSERT INTO archived_bookings (\r\n    id, customer_name, customer_email, customer_phone,\r\n    service_id, service_uuid, staff_id,\r\n    booking_date, booking_time, status, notes,\r\n    created_at, updated_at, archived_at\r\n  )\r\n  SELECT\r\n    id, customer_name, customer_email, customer_phone,\r\n    service_id, service_uuid, staff_id,\r\n    booking_date, booking_time, status, notes,\r\n    created_at, updated_at, CURRENT_TIMESTAMP\r\n  FROM bookings\r\n  WHERE status = 'completed'\r\n    AND booking_date < CURRENT_DATE - INTERVAL '30 days'\r\n  ON CONFLICT (id) DO NOTHING;\r\n\r\n  -- Delete the archived bookings from the main table\r\n  DELETE FROM bookings\r\n  WHERE status = 'completed'\r\n    AND booking_date < CURRENT_DATE - INTERVAL '30 days'\r\n    AND id IN (SELECT id FROM archived_bookings);\r\nEND;\r\n$function$\n"
  },
  {
    "function_name": "force_admin_role",
    "function_definition": "CREATE OR REPLACE FUNCTION public.force_admin_role(target_user_id uuid)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nBEGIN\r\n  -- Insert or update the user profile with admin role\r\n  INSERT INTO user_profiles (id, role, full_name, created_at, updated_at)\r\n  VALUES (\r\n    target_user_id,\r\n    'admin',\r\n    'Admin User',\r\n    NOW(),\r\n    NOW()\r\n  )\r\n  ON CONFLICT (id) DO UPDATE\r\n  SET role = 'admin',\r\n      updated_at = NOW();\r\n\r\n  RETURN true;\r\nEND;\r\n$function$\n"
  },
  {
    "function_name": "get_available_staff",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_available_staff(p_service_id uuid, p_booking_date date, p_booking_time time without time zone)\n RETURNS TABLE(staff_id uuid, staff_name text, staff_email text)\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n  RETURN QUERY\r\n  SELECT DISTINCT\r\n    st.id,\r\n    st.name,\r\n    st.email\r\n  FROM staff st\r\n  JOIN staff_services ss ON st.id = ss.staff_id\r\n  WHERE \r\n    ss.service_id = p_service_id\r\n    AND st.is_active = true\r\n    AND st.id NOT IN (\r\n      -- Exclude staff who are already booked at this time\r\n      SELECT staff_id \r\n      FROM bookings b\r\n      JOIN services s ON b.service_uuid = s.id\r\n      WHERE \r\n        b.booking_date = p_booking_date\r\n        AND b.status IN ('confirmed', 'pending')\r\n        AND b.staff_id IS NOT NULL\r\n        AND (\r\n          -- Check for time overlap\r\n          (b.booking_time <= p_booking_time AND \r\n           b.booking_time + (s.duration || ' minutes')::INTERVAL > p_booking_time)\r\n        )\r\n    );\r\nEND;\r\n$function$\n"
  },
  {
    "function_name": "get_or_create_user_profile",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_or_create_user_profile()\n RETURNS TABLE(id uuid, role text, full_name text, phone text, created_at timestamp with time zone, updated_at timestamp with time zone)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nBEGIN\r\n  -- Try to get existing profile\r\n  RETURN QUERY\r\n  SELECT up.id, up.role, up.full_name, up.phone, up.created_at, up.updated_at\r\n  FROM user_profiles up\r\n  WHERE up.id = auth.uid();\r\n\r\n  -- If no rows returned, create a new profile\r\n  IF NOT FOUND THEN\r\n    INSERT INTO user_profiles (id, role, full_name)\r\n    VALUES (\r\n      auth.uid(),\r\n      'customer',\r\n      COALESCE(\r\n        (SELECT au.email FROM auth.users au WHERE au.id = auth.uid()),\r\n        'User'\r\n      )\r\n    );\r\n\r\n    -- Return the newly created profile\r\n    RETURN QUERY\r\n    SELECT up.id, up.role, up.full_name, up.phone, up.created_at, up.updated_at\r\n    FROM user_profiles up\r\n    WHERE up.id = auth.uid();\r\n  END IF;\r\nEND;\r\n$function$\n"
  },
  {
    "function_name": "get_services_by_staff_categories",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_services_by_staff_categories(p_staff_id uuid)\n RETURNS TABLE(service_id uuid, service_name text, category_id uuid, category_name text, duration integer, price numeric)\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n  RETURN QUERY\r\n  SELECT DISTINCT\r\n    sv.id as service_id,\r\n    sv.name as service_name,\r\n    sc.id as category_id,\r\n    sc.name as category_name,\r\n    sv.duration,\r\n    sv.price\r\n  FROM staff_categories stc\r\n  JOIN service_categories sc ON stc.category_id = sc.id\r\n  JOIN services sv ON sv.category_id = sc.id\r\n  WHERE stc.staff_id = p_staff_id\r\n    AND sv.is_active = true\r\n  ORDER BY sc.name, sv.name;\r\nEND;\r\n$function$\n"
  },
  {
    "function_name": "get_user_role",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_user_role()\n RETURNS text\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nBEGIN\r\n  RETURN (\r\n    SELECT role FROM user_profiles\r\n    WHERE id = auth.uid()\r\n  );\r\nEND;\r\n$function$\n"
  },
  {
    "function_name": "handle_new_user",
    "function_definition": "CREATE OR REPLACE FUNCTION public.handle_new_user()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n  full_name_value TEXT;\r\n  user_role TEXT;\r\nBEGIN\r\n  -- Extract the best available name from metadata\r\n  -- Google OAuth typically provides name, given_name, family_name\r\n  -- Regular signups provide full_name\r\n  full_name_value := COALESCE(\r\n    new.raw_user_meta_data->>'full_name',\r\n    new.raw_user_meta_data->>'name',\r\n    new.raw_user_meta_data->>'displayName',\r\n    CASE\r\n      WHEN new.raw_user_meta_data->>'given_name' IS NOT NULL THEN\r\n        TRIM(CONCAT(\r\n          new.raw_user_meta_data->>'given_name',\r\n          ' ',\r\n          COALESCE(new.raw_user_meta_data->>'family_name', '')\r\n        ))\r\n      ELSE NULL\r\n    END,\r\n    new.email\r\n  );\r\n\r\n  -- Determine role: admin if explicitly set in metadata, otherwise customer\r\n  -- OAuth users (like Google) will always get 'customer' role\r\n  user_role := COALESCE(new.raw_user_meta_data->>'role', 'customer');\r\n\r\n  -- Only allow 'admin' role if it's explicitly set (not from OAuth)\r\n  -- This prevents OAuth users from accidentally becoming admin\r\n  IF user_role = 'admin' AND new.raw_user_meta_data->>'provider' IS NOT NULL THEN\r\n    user_role := 'customer';\r\n  END IF;\r\n\r\n  -- Insert the user profile\r\n  INSERT INTO public.user_profiles (id, full_name, role)\r\n  VALUES (\r\n    new.id,\r\n    full_name_value,\r\n    user_role\r\n  )\r\n  ON CONFLICT (id) DO UPDATE\r\n  SET\r\n    full_name = EXCLUDED.full_name,\r\n    updated_at = NOW()\r\n  WHERE user_profiles.full_name IS NULL OR user_profiles.full_name = '';\r\n\r\n  RETURN new;\r\nEXCEPTION\r\n  WHEN others THEN\r\n    -- Log error but don't fail the signup\r\n    RAISE WARNING 'Error creating user profile: %', SQLERRM;\r\n    RETURN new;\r\nEND;\r\n$function$\n"
  },
  {
    "function_name": "is_admin",
    "function_definition": "CREATE OR REPLACE FUNCTION public.is_admin()\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nBEGIN\r\n  RETURN EXISTS (\r\n    SELECT 1 FROM user_profiles\r\n    WHERE id = auth.uid() AND role = 'admin'\r\n  );\r\nEND;\r\n$function$\n"
  },
  {
    "function_name": "is_staff",
    "function_definition": "CREATE OR REPLACE FUNCTION public.is_staff()\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nBEGIN\r\n  RETURN EXISTS (\r\n    SELECT 1 FROM user_profiles\r\n    WHERE id = auth.uid() AND role IN ('admin', 'staff')\r\n  );\r\nEND;\r\n$function$\n"
  },
  {
    "function_name": "mark_past_bookings_completed",
    "function_definition": "CREATE OR REPLACE FUNCTION public.mark_past_bookings_completed()\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n  UPDATE bookings\r\n  SET status = 'completed',\r\n      updated_at = CURRENT_TIMESTAMP\r\n  WHERE status = 'confirmed'\r\n    AND booking_date < CURRENT_DATE\r\n    OR (booking_date = CURRENT_DATE AND booking_time < CURRENT_TIME - INTERVAL '2 hours');\r\nEND;\r\n$function$\n"
  },
  {
    "function_name": "process_calendar_sync_queue",
    "function_definition": "CREATE OR REPLACE FUNCTION public.process_calendar_sync_queue()\n RETURNS TABLE(processed integer, failed integer)\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n  queue_record RECORD;\r\n  processed_count INT := 0;\r\n  failed_count INT := 0;\r\nBEGIN\r\n  -- Process pending items in the queue\r\n  FOR queue_record IN\r\n    SELECT * FROM calendar_sync_queue\r\n    WHERE status = 'pending'\r\n    AND attempts < 3\r\n    ORDER BY created_at\r\n    LIMIT 10\r\n  LOOP\r\n    BEGIN\r\n      -- Update status to processing\r\n      UPDATE calendar_sync_queue\r\n      SET status = 'processing', attempts = attempts + 1\r\n      WHERE id = queue_record.id;\r\n\r\n      -- Here you would call the Edge Function\r\n      -- For now, we'll just mark as completed\r\n      -- In production, this would be handled by a scheduled job\r\n\r\n      UPDATE calendar_sync_queue\r\n      SET status = 'completed', processed_at = NOW()\r\n      WHERE id = queue_record.id;\r\n\r\n      processed_count := processed_count + 1;\r\n    EXCEPTION WHEN OTHERS THEN\r\n      UPDATE calendar_sync_queue\r\n      SET status = 'failed',\r\n          last_error = SQLERRM,\r\n          processed_at = NOW()\r\n      WHERE id = queue_record.id;\r\n\r\n      failed_count := failed_count + 1;\r\n    END;\r\n  END LOOP;\r\n\r\n  RETURN QUERY SELECT processed_count, failed_count;\r\nEND;\r\n$function$\n"
  },
  {
    "function_name": "promote_to_admin",
    "function_definition": "CREATE OR REPLACE FUNCTION public.promote_to_admin(secret_key text)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n  result JSON;\r\nBEGIN\r\n  -- Check if the secret key is correct\r\n  IF secret_key != 'spa-admin-2024' THEN\r\n    RETURN json_build_object('success', false, 'message', 'Invalid secret key');\r\n  END IF;\r\n\r\n  -- Check if user is authenticated\r\n  IF auth.uid() IS NULL THEN\r\n    RETURN json_build_object('success', false, 'message', 'User not authenticated');\r\n  END IF;\r\n\r\n  -- Check if profile exists, if not create it\r\n  INSERT INTO user_profiles (id, role, full_name)\r\n  VALUES (\r\n    auth.uid(),\r\n    'admin',\r\n    COALESCE(\r\n      (SELECT email FROM auth.users WHERE id = auth.uid()),\r\n      'Admin User'\r\n    )\r\n  )\r\n  ON CONFLICT (id) DO UPDATE\r\n  SET role = 'admin',\r\n      updated_at = NOW();\r\n\r\n  RETURN json_build_object(\r\n    'success', true,\r\n    'message', 'Successfully promoted to admin',\r\n    'role', 'admin'\r\n  );\r\nEND;\r\n$function$\n"
  },
  {
    "function_name": "promote_to_admin_simple",
    "function_definition": "CREATE OR REPLACE FUNCTION public.promote_to_admin_simple(target_user_id uuid, secret_key text)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n  result JSON;\r\nBEGIN\r\n  -- Verify the secret key\r\n  IF secret_key != 'spa-admin-2024' THEN\r\n    RETURN json_build_object(\r\n      'success', false,\r\n      'error', 'Invalid secret key'\r\n    );\r\n  END IF;\r\n\r\n  -- Verify it's the current user (security check)\r\n  IF target_user_id != auth.uid() THEN\r\n    RETURN json_build_object(\r\n      'success', false,\r\n      'error', 'Can only promote your own account'\r\n    );\r\n  END IF;\r\n\r\n  -- Try to update existing profile\r\n  UPDATE user_profiles\r\n  SET role = 'admin',\r\n      updated_at = NOW()\r\n  WHERE id = target_user_id;\r\n\r\n  -- If no rows were updated, insert a new profile\r\n  IF NOT FOUND THEN\r\n    INSERT INTO user_profiles (id, role, full_name, created_at, updated_at)\r\n    SELECT\r\n      target_user_id,\r\n      'admin',\r\n      COALESCE(\r\n        (SELECT raw_user_meta_data->>'full_name' FROM auth.users WHERE id = target_user_id),\r\n        (SELECT raw_user_meta_data->>'name' FROM auth.users WHERE id = target_user_id),\r\n        (SELECT email FROM auth.users WHERE id = target_user_id)\r\n      ),\r\n      NOW(),\r\n      NOW();\r\n  END IF;\r\n\r\n  -- Return success with the new role\r\n  SELECT json_build_object(\r\n    'success', true,\r\n    'role', role,\r\n    'message', 'Successfully promoted to admin'\r\n  ) INTO result\r\n  FROM user_profiles\r\n  WHERE id = target_user_id;\r\n\r\n  RETURN result;\r\nEXCEPTION\r\n  WHEN OTHERS THEN\r\n    RETURN json_build_object(\r\n      'success', false,\r\n      'error', SQLERRM\r\n    );\r\nEND;\r\n$function$\n"
  },
  {
    "function_name": "trigger_calendar_sync",
    "function_definition": "CREATE OR REPLACE FUNCTION public.trigger_calendar_sync()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n  action_type TEXT;\r\n  booking_data JSON;\r\nBEGIN\r\n  -- Determine the action type\r\n  IF TG_OP = 'INSERT' THEN\r\n    action_type := 'create';\r\n    booking_data := row_to_json(NEW);\r\n  ELSIF TG_OP = 'UPDATE' THEN\r\n    -- Only sync if important fields changed\r\n    IF (OLD.booking_date IS DISTINCT FROM NEW.booking_date OR\r\n        OLD.booking_time IS DISTINCT FROM NEW.booking_time OR\r\n        OLD.status IS DISTINCT FROM NEW.status OR\r\n        OLD.service_id IS DISTINCT FROM NEW.service_id OR\r\n        OLD.staff_id IS DISTINCT FROM NEW.staff_id OR\r\n        OLD.customer_name IS DISTINCT FROM NEW.customer_name OR\r\n        OLD.customer_email IS DISTINCT FROM NEW.customer_email) THEN\r\n      action_type := 'update';\r\n      booking_data := row_to_json(NEW);\r\n    ELSE\r\n      RETURN NEW;\r\n    END IF;\r\n  ELSIF TG_OP = 'DELETE' THEN\r\n    action_type := 'delete';\r\n    booking_data := row_to_json(OLD);\r\n  END IF;\r\n\r\n  -- We'll queue this for processing instead of calling the Edge Function directly\r\n  -- This ensures the trigger doesn't fail if the Edge Function is unavailable\r\n  INSERT INTO calendar_sync_queue (booking_id, action, booking_data, status)\r\n  VALUES (\r\n    COALESCE(NEW.id, OLD.id),\r\n    action_type,\r\n    booking_data,\r\n    'pending'\r\n  );\r\n\r\n  RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "function_name": "update_updated_at_column",
    "function_definition": "CREATE OR REPLACE FUNCTION public.update_updated_at_column()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n  NEW.updated_at = NOW();\r\n  RETURN NEW;\r\nEND;\r\n$function$\n"
  }
]