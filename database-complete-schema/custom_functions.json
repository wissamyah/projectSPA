[
  {
    "function_name": "archive_old_bookings",
    "function_definition": "CREATE OR REPLACE FUNCTION public.archive_old_bookings()\n RETURNS void\n LANGUAGE plpgsql\n SET search_path TO 'public', 'pg_catalog'\nAS $function$\r\nBEGIN\r\n  -- Insert completed bookings older than 30 days into archived_bookings\r\n  INSERT INTO archived_bookings (\r\n    id, customer_name, customer_email, customer_phone,\r\n    service_id, service_uuid, staff_id,\r\n    booking_date, booking_time, status, notes,\r\n    created_at, updated_at, archived_at\r\n  )\r\n  SELECT\r\n    id, customer_name, customer_email, customer_phone,\r\n    service_id, service_uuid, staff_id,\r\n    booking_date, booking_time, status, notes,\r\n    created_at, updated_at, CURRENT_TIMESTAMP\r\n  FROM bookings\r\n  WHERE status = 'completed'\r\n    AND booking_date < CURRENT_DATE - INTERVAL '30 days'\r\n  ON CONFLICT (id) DO NOTHING;\r\n\r\n  -- Delete the archived bookings from the main table\r\n  DELETE FROM bookings\r\n  WHERE status = 'completed'\r\n    AND booking_date < CURRENT_DATE - INTERVAL '30 days'\r\n    AND id IN (SELECT id FROM archived_bookings);\r\nEND;\r\n$function$\n"
  },
  {
    "function_name": "get_available_staff",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_available_staff(p_service_id uuid, p_booking_date date, p_booking_time time without time zone)\n RETURNS TABLE(staff_id uuid, staff_name text, staff_email text)\n LANGUAGE plpgsql\n SET search_path TO 'public', 'pg_catalog'\nAS $function$\r\nBEGIN\r\n  RETURN QUERY\r\n  SELECT DISTINCT\r\n    st.id,\r\n    st.name,\r\n    st.email\r\n  FROM staff st\r\n  JOIN staff_services ss ON st.id = ss.staff_id\r\n  WHERE\r\n    ss.service_id = p_service_id\r\n    AND st.is_active = true\r\n    AND st.id NOT IN (\r\n      -- Exclude staff who are already booked at this time\r\n      SELECT b.staff_id\r\n      FROM bookings b\r\n      JOIN services s ON b.service_uuid = s.id\r\n      WHERE\r\n        b.booking_date = p_booking_date\r\n        AND b.status IN ('confirmed', 'pending')\r\n        AND b.staff_id IS NOT NULL\r\n        AND (\r\n          -- Check for time overlap\r\n          (b.booking_time <= p_booking_time AND\r\n           b.booking_time + (s.duration || ' minutes')::INTERVAL > p_booking_time)\r\n        )\r\n    );\r\nEND;\r\n$function$\n"
  },
  {
    "function_name": "get_or_create_user_profile",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_or_create_user_profile()\n RETURNS TABLE(id uuid, role text, full_name text, phone text, created_at timestamp with time zone, updated_at timestamp with time zone)\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'auth', 'pg_catalog'\nAS $function$\r\nBEGIN\r\n  -- Try to get existing profile\r\n  RETURN QUERY\r\n  SELECT up.id, up.role, up.full_name, up.phone, up.created_at, up.updated_at\r\n  FROM user_profiles up\r\n  WHERE up.id = auth.uid();\r\n\r\n  -- If no rows returned, create a new profile\r\n  IF NOT FOUND THEN\r\n    INSERT INTO user_profiles (id, role, full_name)\r\n    VALUES (\r\n      auth.uid(),\r\n      'customer',\r\n      COALESCE(\r\n        (SELECT au.email FROM auth.users au WHERE au.id = auth.uid()),\r\n        'User'\r\n      )\r\n    );\r\n\r\n    -- Return the newly created profile\r\n    RETURN QUERY\r\n    SELECT up.id, up.role, up.full_name, up.phone, up.created_at, up.updated_at\r\n    FROM user_profiles up\r\n    WHERE up.id = auth.uid();\r\n  END IF;\r\nEND;\r\n$function$\n"
  },
  {
    "function_name": "get_services_by_staff_categories",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_services_by_staff_categories(p_staff_id uuid)\n RETURNS TABLE(service_id uuid, service_name text, category_id uuid, category_name text, duration integer, price numeric)\n LANGUAGE plpgsql\n SET search_path TO 'public', 'pg_catalog'\nAS $function$\r\nBEGIN\r\n  RETURN QUERY\r\n  SELECT DISTINCT\r\n    sv.id as service_id,\r\n    sv.name as service_name,\r\n    sc.id as category_id,\r\n    sc.name as category_name,\r\n    sv.duration,\r\n    sv.price\r\n  FROM staff_categories stc\r\n  JOIN service_categories sc ON stc.category_id = sc.id\r\n  JOIN services sv ON sv.category_id = sc.id\r\n  WHERE stc.staff_id = p_staff_id\r\n    AND sv.is_active = true\r\n  ORDER BY sc.name, sv.name;\r\nEND;\r\n$function$\n"
  },
  {
    "function_name": "get_user_role",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_user_role()\n RETURNS text\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'auth', 'pg_catalog'\nAS $function$\r\nBEGIN\r\n  RETURN (\r\n    SELECT role FROM user_profiles\r\n    WHERE id = auth.uid()\r\n  );\r\nEND;\r\n$function$\n"
  },
  {
    "function_name": "handle_new_user",
    "function_definition": "CREATE OR REPLACE FUNCTION public.handle_new_user()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'auth', 'pg_catalog'\nAS $function$\r\n  DECLARE\r\n    full_name_value TEXT;\r\n  BEGIN\r\n    -- Extract the best available name from metadata\r\n    full_name_value := COALESCE(\r\n      new.raw_user_meta_data->>'full_name',\r\n      new.raw_user_meta_data->>'name',\r\n      new.raw_user_meta_data->>'displayName',\r\n      CASE\r\n        WHEN new.raw_user_meta_data->>'given_name' IS NOT NULL THEN\r\n          TRIM(CONCAT(\r\n            new.raw_user_meta_data->>'given_name',\r\n            ' ',\r\n            COALESCE(new.raw_user_meta_data->>'family_name', '')\r\n          ))\r\n        ELSE NULL\r\n      END,\r\n      new.email\r\n    );\r\n\r\n    -- Insert the user profile with default 'customer' role\r\n    INSERT INTO public.user_profiles (id, full_name, role)\r\n    VALUES (\r\n      new.id,\r\n      full_name_value,\r\n      'customer' -- Always default to customer\r\n    )\r\n    ON CONFLICT (id) DO UPDATE\r\n    SET\r\n      full_name = EXCLUDED.full_name,\r\n      updated_at = NOW()\r\n    WHERE user_profiles.full_name IS NULL OR user_profiles.full_name = '';\r\n\r\n    RETURN new;\r\n  EXCEPTION\r\n    WHEN others THEN\r\n      RAISE WARNING 'Error creating user profile: %', SQLERRM;\r\n      RETURN new;\r\n  END;\r\n$function$\n"
  },
  {
    "function_name": "is_admin",
    "function_definition": "CREATE OR REPLACE FUNCTION public.is_admin()\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'auth', 'pg_catalog'\nAS $function$\r\nBEGIN\r\n  RETURN EXISTS (\r\n    SELECT 1 FROM user_profiles\r\n    WHERE id = auth.uid() AND role = 'admin'\r\n  );\r\nEND;\r\n$function$\n"
  },
  {
    "function_name": "is_staff",
    "function_definition": "CREATE OR REPLACE FUNCTION public.is_staff()\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'auth', 'pg_catalog'\nAS $function$\r\nBEGIN\r\n  RETURN EXISTS (\r\n    SELECT 1 FROM user_profiles\r\n    WHERE id = auth.uid() AND role IN ('admin', 'staff')\r\n  );\r\nEND;\r\n$function$\n"
  },
  {
    "function_name": "mark_past_bookings_completed",
    "function_definition": "CREATE OR REPLACE FUNCTION public.mark_past_bookings_completed()\n RETURNS void\n LANGUAGE plpgsql\n SET search_path TO 'public', 'pg_catalog'\nAS $function$\r\nBEGIN\r\n  UPDATE bookings\r\n  SET status = 'completed',\r\n      updated_at = CURRENT_TIMESTAMP\r\n  WHERE status = 'confirmed'\r\n    AND booking_date < CURRENT_DATE\r\n    OR (booking_date = CURRENT_DATE AND booking_time < CURRENT_TIME - INTERVAL '2 hours');\r\nEND;\r\n$function$\n"
  },
  {
    "function_name": "setup_initial_admin",
    "function_definition": "CREATE OR REPLACE FUNCTION public.setup_initial_admin(user_email text)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'auth', 'pg_catalog'\nAS $function$\r\n  DECLARE\r\n    user_id UUID;\r\n    existing_admins INTEGER;\r\n  BEGIN\r\n    -- Check if any admins exist\r\n    SELECT COUNT(*) INTO existing_admins\r\n    FROM user_profiles\r\n    WHERE role = 'admin';\r\n\r\n    IF existing_admins > 0 THEN\r\n      RETURN json_build_object(\r\n        'success', false,\r\n        'message', 'Admin already exists'\r\n      );\r\n    END IF;\r\n\r\n    -- Find user by email\r\n    SELECT id INTO user_id\r\n    FROM auth.users\r\n    WHERE email = user_email;\r\n\r\n    IF user_id IS NULL THEN\r\n      RETURN json_build_object(\r\n        'success', false,\r\n        'message', 'User not found. Please sign up first.'\r\n      );\r\n    END IF;\r\n\r\n    -- Make them admin\r\n    INSERT INTO user_profiles (id, role, full_name)\r\n    VALUES (user_id, 'admin', 'Administrator')\r\n    ON CONFLICT (id)\r\n    DO UPDATE SET role = 'admin', updated_at = NOW();\r\n\r\n    RETURN json_build_object(\r\n      'success', true,\r\n      'message', 'Admin created successfully',\r\n      'user_id', user_id\r\n    );\r\n  END;\r\n$function$\n"
  },
  {
    "function_name": "update_updated_at_column",
    "function_definition": "CREATE OR REPLACE FUNCTION public.update_updated_at_column()\n RETURNS trigger\n LANGUAGE plpgsql\n SET search_path TO 'public', 'pg_catalog'\nAS $function$\r\nBEGIN\r\n  NEW.updated_at = NOW();\r\n  RETURN NEW;\r\nEND;\r\n$function$\n"
  }
]