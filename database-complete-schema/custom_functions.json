[
    {
      "function_name": "archive_old_bookings",
      "function_definition": "CREATE OR REPLACE FUNCTION public.archive_old_bookings()\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n  -- Insert completed bookings older than 30 days into archived_bookings\r\n  INSERT INTO archived_bookings (\r\n    id, customer_name, customer_email, customer_phone,\r\n    service_id, service_uuid, staff_id,\r\n    booking_date, booking_time, status, notes,\r\n    created_at, updated_at, archived_at\r\n  )\r\n  SELECT\r\n    id, customer_name, customer_email, customer_phone,\r\n    service_id, service_uuid, staff_id,\r\n    booking_date, booking_time, status, notes,\r\n    created_at, updated_at, CURRENT_TIMESTAMP\r\n  FROM bookings\r\n  WHERE status = 'completed'\r\n    AND booking_date < CURRENT_DATE - INTERVAL '30 days'\r\n  ON CONFLICT (id) DO NOTHING;\r\n\r\n  -- Delete the archived bookings from the main table\r\n  DELETE FROM bookings\r\n  WHERE status = 'completed'\r\n    AND booking_date < CURRENT_DATE - INTERVAL '30 days'\r\n    AND id IN (SELECT id FROM archived_bookings);\r\nEND;\r\n$function$\n"
    },
    {
      "function_name": "get_available_staff",
      "function_definition": "CREATE OR REPLACE FUNCTION public.get_available_staff(p_service_id uuid, p_booking_date date, p_booking_time time without time zone)\n RETURNS TABLE(staff_id uuid, staff_name text, staff_email text)\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n  RETURN QUERY\r\n  SELECT DISTINCT\r\n    st.id,\r\n    st.name,\r\n    st.email\r\n  FROM staff st\r\n  JOIN staff_services ss ON st.id = ss.staff_id\r\n  WHERE \r\n    ss.service_id = p_service_id\r\n    AND st.is_active = true\r\n    AND st.id NOT IN (\r\n      -- Exclude staff who are already booked at this time\r\n      SELECT staff_id \r\n      FROM bookings b\r\n      JOIN services s ON b.service_uuid = s.id\r\n      WHERE \r\n        b.booking_date = p_booking_date\r\n        AND b.status IN ('confirmed', 'pending')\r\n        AND b.staff_id IS NOT NULL\r\n        AND (\r\n          -- Check for time overlap\r\n          (b.booking_time <= p_booking_time AND \r\n           b.booking_time + (s.duration || ' minutes')::INTERVAL > p_booking_time)\r\n        )\r\n    );\r\nEND;\r\n$function$\n"
    },
    {
      "function_name": "get_services_by_staff_categories",
      "function_definition": "CREATE OR REPLACE FUNCTION public.get_services_by_staff_categories(p_staff_id uuid)\n RETURNS TABLE(service_id uuid, service_name text, category_id uuid, category_name text, duration integer, price numeric)\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n  RETURN QUERY\r\n  SELECT DISTINCT\r\n    sv.id as service_id,\r\n    sv.name as service_name,\r\n    sc.id as category_id,\r\n    sc.name as category_name,\r\n    sv.duration,\r\n    sv.price\r\n  FROM staff_categories stc\r\n  JOIN service_categories sc ON stc.category_id = sc.id\r\n  JOIN services sv ON sv.category_id = sc.id\r\n  WHERE stc.staff_id = p_staff_id\r\n    AND sv.is_active = true\r\n  ORDER BY sc.name, sv.name;\r\nEND;\r\n$function$\n"
    },
    {
      "function_name": "is_admin",
      "function_definition": "CREATE OR REPLACE FUNCTION public.is_admin()\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nBEGIN\r\n  -- Check if the user's email matches admin email\r\n  -- You can modify this to check for a role instead\r\n  RETURN auth.jwt() ->> 'email' = 'admin@example.com' \r\n    OR auth.uid() IS NOT NULL; -- For now, any authenticated user is treated as admin\r\nEND;\r\n$function$\n"
    },
    {
      "function_name": "mark_past_bookings_completed",
      "function_definition": "CREATE OR REPLACE FUNCTION public.mark_past_bookings_completed()\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n  UPDATE bookings\r\n  SET status = 'completed',\r\n      updated_at = CURRENT_TIMESTAMP\r\n  WHERE status = 'confirmed'\r\n    AND booking_date < CURRENT_DATE\r\n    OR (booking_date = CURRENT_DATE AND booking_time < CURRENT_TIME - INTERVAL '2 hours');\r\nEND;\r\n$function$\n"
    },
    {
      "function_name": "process_calendar_sync_queue",
      "function_definition": "CREATE OR REPLACE FUNCTION public.process_calendar_sync_queue()\n RETURNS TABLE(processed integer, failed integer)\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n  queue_record RECORD;\r\n  processed_count INT := 0;\r\n  failed_count INT := 0;\r\nBEGIN\r\n  -- Process pending items in the queue\r\n  FOR queue_record IN\r\n    SELECT * FROM calendar_sync_queue\r\n    WHERE status = 'pending'\r\n    AND attempts < 3\r\n    ORDER BY created_at\r\n    LIMIT 10\r\n  LOOP\r\n    BEGIN\r\n      -- Update status to processing\r\n      UPDATE calendar_sync_queue\r\n      SET status = 'processing', attempts = attempts + 1\r\n      WHERE id = queue_record.id;\r\n\r\n      -- Here you would call the Edge Function\r\n      -- For now, we'll just mark as completed\r\n      -- In production, this would be handled by a scheduled job\r\n\r\n      UPDATE calendar_sync_queue\r\n      SET status = 'completed', processed_at = NOW()\r\n      WHERE id = queue_record.id;\r\n\r\n      processed_count := processed_count + 1;\r\n    EXCEPTION WHEN OTHERS THEN\r\n      UPDATE calendar_sync_queue\r\n      SET status = 'failed',\r\n          last_error = SQLERRM,\r\n          processed_at = NOW()\r\n      WHERE id = queue_record.id;\r\n\r\n      failed_count := failed_count + 1;\r\n    END;\r\n  END LOOP;\r\n\r\n  RETURN QUERY SELECT processed_count, failed_count;\r\nEND;\r\n$function$\n"
    },
    {
      "function_name": "trigger_calendar_sync",
      "function_definition": "CREATE OR REPLACE FUNCTION public.trigger_calendar_sync()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n  action_type TEXT;\r\n  booking_data JSON;\r\nBEGIN\r\n  -- Determine the action type\r\n  IF TG_OP = 'INSERT' THEN\r\n    action_type := 'create';\r\n    booking_data := row_to_json(NEW);\r\n  ELSIF TG_OP = 'UPDATE' THEN\r\n    -- Only sync if important fields changed\r\n    IF (OLD.booking_date IS DISTINCT FROM NEW.booking_date OR\r\n        OLD.booking_time IS DISTINCT FROM NEW.booking_time OR\r\n        OLD.status IS DISTINCT FROM NEW.status OR\r\n        OLD.service_id IS DISTINCT FROM NEW.service_id OR\r\n        OLD.staff_id IS DISTINCT FROM NEW.staff_id OR\r\n        OLD.customer_name IS DISTINCT FROM NEW.customer_name OR\r\n        OLD.customer_email IS DISTINCT FROM NEW.customer_email) THEN\r\n      action_type := 'update';\r\n      booking_data := row_to_json(NEW);\r\n    ELSE\r\n      RETURN NEW;\r\n    END IF;\r\n  ELSIF TG_OP = 'DELETE' THEN\r\n    action_type := 'delete';\r\n    booking_data := row_to_json(OLD);\r\n  END IF;\r\n\r\n  -- We'll queue this for processing instead of calling the Edge Function directly\r\n  -- This ensures the trigger doesn't fail if the Edge Function is unavailable\r\n  INSERT INTO calendar_sync_queue (booking_id, action, booking_data, status)\r\n  VALUES (\r\n    COALESCE(NEW.id, OLD.id),\r\n    action_type,\r\n    booking_data,\r\n    'pending'\r\n  );\r\n\r\n  RETURN NEW;\r\nEND;\r\n$function$\n"
    },
    {
      "function_name": "update_updated_at_column",
      "function_definition": "CREATE OR REPLACE FUNCTION public.update_updated_at_column()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n  NEW.updated_at = NOW();\r\n  RETURN NEW;\r\nEND;\r\n$function$\n"
    }
  ]